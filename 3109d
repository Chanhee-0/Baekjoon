#include<iostream>
#include<string>

using namespace std;

int map[10001][501];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int r, c, pos, ans = 0;
	string s, t = ".x";

	cin >> r >> c;

	for (int i = 0; i < r; i++) {
		cin >> s;
		for (int j = 0; j < c; j++) {
			if (s[j] == '.')
				map[i][j] = 0;
			else if (s[j] == 'x')
				map[i][j] = 1;
		}
	}

	for (int i = 0; i < r; i++) {
		pos = i;
		for (int j = 0; j < c - 1; j++) {
			if (pos + 1 <= r - 1 && map[pos][j + 2] == 1 && map[pos + 1][j + 2] == 1) {
				map[pos + 1][j + 1] = 1;
				pos++;
				if (j + 1 == c - 1) {
					ans++;
					break;
				}
			}
			else if (pos - 1 >= 0 && map[pos - 1][j + 1] == 0) {
				map[pos - 1][j + 1] = 1;
				pos--;
				if (j + 1 == c - 1) {
					ans++;
					break;
				}
			}
			else if (map[pos][j + 1] == 0) {
				map[pos][j + 1] = 1;
				if (j + 1 == c - 1) {
					ans++;
					break;
				}
			}
			else if (pos + 1 <= r - 1 && map[pos + 1][j + 1] == 0) {
				map[pos + 1][j + 1] = 1;
				pos++;
				if (j + 1 == c - 1) {
					ans++;
					break;
				}
			}
			else
				break;
		}
	}

	cout << ans;

	return 0;
}
/*
3109 빵집
1. 경로 검사 각 열을 검사하여 경로가 적은 곳(한개)을 저장push (2, 3) 3 이전이면 2로 가기위해 위나 아래로 이동한다.
2. 도달 하면 pop 다음 한개 입구를 찾아 이동
3 5
...x.
.x.x.
.x...
3 5
.x...
.x.x.
...x.
*/
#include<iostream>
#include<queue>
#include<string>

using namespace std;

int map[10001][501];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	queue <pair<int, int>> q;
 
	int r, c, pos, ans = 0;
	string s;

	cin >> r >> c;

	for (int i = 0; i < r; i++) {
		cin >> s;
		for (int j = 0; j < c; j++) {
			if (s[j] == '.')
				map[i][j] = 0;
			else if (s[j] == 'x')
				map[i][j] = 1;
		}
	}

	for (int j = 1; j < c - 1; j++) {
		pos = 0;
		for (int i = 0; i < r; i++) {
			if (map[i][j] == 0)
				pos++;
		}
		if (pos == 1) {
			for (int i = 0; i < r; i++) {
				if (map[i][j] == 0)
					q.push(make_pair(i, j));
			}
		}
	}

	for (int i = 0; i < r; i++) {
		pos = i;
		for (int j = 0; j < c - 1; j++) {
			if (q.size() > 0 && j < q.front().second) {
				if (pos < q.front().first && map[pos + 1][j + 1] == 0 && pos + 1 <= r - 1) {
					map[pos + 1][j + 1] = 1;
					pos++;
					if (pos == q.front().first && j + 1 == q.front().second)
						q.pop();
					if (j + 1 == c - 1) {
						ans++;
						break;
					}
				}
				else if (pos == q.front().first && map[pos][j + 1] == 0) {
					map[pos][j + 1] = 1;
					if (pos == q.front().first && j + 1 == q.front().second)
						q.pop();
					if (j + 1 == c - 1) {
						ans++;
						break;
					}
				}
				else if (pos > q.front().first && pos - 1 >= 0 && map[pos - 1][j + 1] == 0) {
					map[pos - 1][j + 1] = 1;
					pos--;
					if (pos == q.front().first && j + 1 == q.front().second)
						q.pop();
					if (j + 1 == c - 1) {
						ans++;
						break;
					}
				}
				else
					break;
			
			}
			else {
				if (pos - 1 >= 0 && map[pos - 1][j + 1] == 0) {
					map[pos - 1][j + 1] = 1;
					pos--;
					if (j + 1 == c - 1) {
						ans++;
						break;
					}
				}
				else if (map[pos][j + 1] == 0) {
					map[pos][j + 1] = 1;
					if (j + 1 == c - 1) {
						ans++;
						break;
					}
				}
				else if (pos + 1 <= r - 1 && map[pos + 1][j + 1] == 0) {
					map[pos + 1][j + 1] = 1;
					pos++;
					if (j + 1 == c - 1) {
						ans++;
						break;
					}
				}
				else
					break;
			}
		}
	}

	cout << ans;

	return 0;
}
/*
3109 빵집
1. 경로 검사 각 열을 검사하여 경로가 적은 곳(한개)을 저장push (2, 3) 3 이전이면 2로 가기위해 위나 아래로 이동한다.
2. 도달 하면 pop 다음 한개 입구를 찾아 이동
그래프 탐색 공부 전에는 풀릴것같지가 않다.
공부하고 다시 풀어보자
5 9
.x.....x.
.x..x..x.
.x..x..x.
....x....
.x..x..x.
3 5
...x.
.x.x.
.x...
3 5
.x...
.x.x.
...x.
*/
